<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

    <!-- Primary Meta Tags -->
    <title>Pomegranate Panic - A Pom's Wild Descent</title>
    <meta name="title" content="Pomegranate Panic - A Pom's Wild Descent">
    <meta name="description" content="Guide a tumbling pomegranate down an endless descent! Place ramps, hit bumpers, rack up combos, and chase high scores in this addictive arcade game.">
    <meta name="keywords" content="pomegranate, arcade game, endless runner, mobile game, browser game, casual game">
    <meta name="author" content="Pomegranate Panic">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://zeveck.github.io/pomegranatepanic/">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://zeveck.github.io/pomegranatepanic/">
    <meta property="og:title" content="Pomegranate Panic - A Pom's Wild Descent">
    <meta property="og:description" content="Guide a tumbling pomegranate down an endless descent! Place ramps, hit bumpers, rack up combos, and chase high scores in this addictive arcade game.">
    <meta property="og:image" content="https://zeveck.github.io/pomegranatepanic/social-card.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://zeveck.github.io/pomegranatepanic/">
    <meta property="twitter:title" content="Pomegranate Panic - A Pom's Wild Descent">
    <meta property="twitter:description" content="Guide a tumbling pomegranate down an endless descent! Place ramps, hit bumpers, rack up combos, and chase high scores in this addictive arcade game.">
    <meta property="twitter:image" content="https://zeveck.github.io/pomegranatepanic/social-card.jpg">

    <!-- Favicons and Icons -->
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">

    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            background: #1a1a2e;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
        // Prevent all default touch behaviors
        document.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
        document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        document.addEventListener('touchend', e => e.preventDefault(), { passive: false });
        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        document.addEventListener('gestureend', e => e.preventDefault());

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Version
        const VERSION = 'v0.3.0';

        // Game constants
        const GRAVITY = 800; // Faster falling
        const BOUNCE_DAMPING = 0.5;
        const WALL_BOUNCE = 0.6;
        const BASE_ROLL_SPEED = 80; // Faster initial roll
        const SPEED_INCREASE_RATE = 0.06; // Speed multiplier increase per second

        // Ramp configurations
        const RAMP_ANGLES = [-35, -20, -10, 10, 20, 35]; // degrees, negative = left, positive = right
        const RAMP_LENGTHS = [80, 120, 160]; // pixels at base resolution
        const RAMP_THICKNESS = 12;

        // Bumper configurations
        const BUMPER_CONFIGS = {
            small:  { radius: 28, points: 50,  color: '#FF6B6B', lightColor: '#FFE66D' },
            medium: { radius: 32, points: 100, color: '#4ECDC4', lightColor: '#FFFFFF' },
            large:  { radius: 38, points: 150, color: '#9B59B6', lightColor: '#E74C3C' }
        };
        const JACKPOT_BUMPER = {
            radius: 50,
            pointsPerHit: 1000,
            jackpotBonus: 5000,
            maxHits: 5,
            color: '#FFD700',
            lightColor: '#FFFFFF',
            shrinkPerHit: 0.15
        };
        const BUMPER_BOUNCE_FORCE = 500;
        const BUMPER_RECOIL_DURATION = 0.15;
        const BUMPER_LIGHT_DURATION = 0.25;
        const BUMPER_RECOIL_SCALE = 0.85;
        const BUMPER_MIN_SPAWN_INTERVAL = 2;
        const BUMPER_MAX_SPAWN_INTERVAL = 5;
        const BUMPER_SPAWN_MARGIN = 60;
        const BUMPER_MIN_DISTANCE = 100;
        const JACKPOT_SPAWN_INTERVAL = 45; // Minimum seconds between jackpot spawns
        const DEPTH_VALUE_SCALE = 2000; // Every 2000px depth doubles bumper value

        // Game state
        let gameState = 'playing'; // 'playing', 'gameover'
        let score = 0;
        let bonusScore = 0; // Accumulated bonus points from bounces
        let speedMultiplier = 1;
        let gameTime = 0;
        let gameOverRotation = 0;
        let gameOverFadeIn = 0; // 0-1 fade in for game over UI
        let cameraY = 0; // Vertical scroll offset
        let cameraVelocity = 0; // Smooth camera velocity

        // Pomegranate state
        let pom = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            radius: 18,
            rotation: 0,
            onRamp: null,
            rampProgress: 0, // 0 to 1, position along current ramp
            nibBump: 0 // Intensity of current nib bump (0-1)
        };

        // Ramps
        let ramps = [];
        let nextRamp = null;
        let lastRampDirection = 1; // 1 = right, -1 = left (for alternating)

        // Ghost preview state
        let ghostPosition = null; // {x, y} or null when not showing

        // Fall tracking for bounce/bonus system
        let fallStartY = null;
        let floatingTexts = []; // Bonus point displays
        let isBouncing = false; // Prevent re-landing during bounce
        let comboCount = 0; // Track consecutive bounces

        // Bumper state
        let bumpers = [];
        let bumperSpawnTimer = 0;
        let nextBumperSpawnTime = 0;
        let maxDepth = 0; // Maximum depth reached (for scaling bumper values)
        let lastJackpotSpawnTime = 0; // Game time when last jackpot spawned
        let hasActiveJackpot = false; // Only one jackpot at a time

        // Hades fire state
        let fireParticles = [];
        let fireFlareIntensity = 0; // 0-1, increases on game over
        let fallingIntoFire = false; // True when pom is falling into fire
        let fireDeathTimer = 0; // Time spent in fire death animation
        const FIRE_HEIGHT = 120; // Height of fire zone in pixels
        const FIRE_PARTICLE_COUNT = 60; // Base number of fire particles
        const FIRE_DEATH_DURATION = 0.8; // Seconds to show fire flare before game over

        // Seed collection state
        let seeds = [];                    // Active seeds on screen
        let collectedSeeds = 0;            // 0-6 seeds collected
        let seedSpawnTimer = 0;            // Time since last seed spawn
        let totalSeedsSpawned = 0;         // Track total spawned (max 6)
        let isGoldenPom = false;           // True when all 6 collected
        const SEED_SPAWN_INTERVAL = 30;    // Seconds between seed spawns
        const MAX_SEEDS = 6;               // Maximum seeds per game
        const SEED_COLLECT_RADIUS = 25;    // Collision radius for collection

        // Screen dimensions (will be set on resize)
        let width, height, scale;

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            scale = Math.min(width, height) / 400; // Base scale for consistent sizing
        }

        function generateRandomRamp() {
            // Tend to alternate directions, but with 30% chance of same direction
            const preferredDirection = -lastRampDirection;
            const actualDirection = Math.random() < 0.7 ? preferredDirection : lastRampDirection;

            // Filter angles by direction
            const availableAngles = RAMP_ANGLES.filter(a =>
                actualDirection > 0 ? a > 0 : a < 0
            );
            const angle = availableAngles[Math.floor(Math.random() * availableAngles.length)];
            const length = RAMP_LENGTHS[Math.floor(Math.random() * RAMP_LENGTHS.length)] * scale;

            lastRampDirection = actualDirection;
            return { angle, length };
        }

        function createRamp(x, y, angle, length) {
            const rad = angle * Math.PI / 180;
            return {
                x,
                y,
                angle,
                length,
                rad,
                // Calculate endpoints
                x1: x - Math.cos(rad) * length / 2,
                y1: y - Math.sin(rad) * length / 2,
                x2: x + Math.cos(rad) * length / 2,
                y2: y + Math.sin(rad) * length / 2,
                opacity: 1,
                passed: false
            };
        }

        function initGame() {
            gameState = 'playing';
            score = 0;
            bonusScore = 0;
            speedMultiplier = 1;
            gameTime = 0;
            gameOverFadeIn = 0;
            ramps = [];

            // Create starting ramp slightly left of center
            const startRamp = createRamp(
                width / 2 - 40 * scale,
                height * 0.1,
                5, // Very slight right tilt to start
                140 * scale
            );
            ramps.push(startRamp);

            // Initialize pomegranate radius first
            const pomRadius = 18 * scale;

            // Position pomegranate at the LEFT (uphill) end of the starting ramp
            pom = {
                x: startRamp.x1 + 30 * scale,
                y: startRamp.y1 - pomRadius - 5,
                vx: 0,
                vy: 0,
                radius: pomRadius,
                rotation: 0,
                onRamp: startRamp,
                rampProgress: -0.42, // Start very close to the left end
                nibBump: 0
            };

            // Generate first "next" ramp
            nextRamp = generateRandomRamp();

            // Initialize camera so pom starts at 1/3 from top
            cameraY = pom.y - height / 3;
            cameraVelocity = 0;

            // Reset fall tracking and floating texts
            fallStartY = null;
            floatingTexts = [];
            isBouncing = false;
            comboCount = 0;

            // Reset bumpers
            bumpers = [];
            bumperSpawnTimer = 0;
            nextBumperSpawnTime = BUMPER_MIN_SPAWN_INTERVAL;
            maxDepth = 0;
            lastJackpotSpawnTime = 0;
            hasActiveJackpot = false;

            // Reset seeds
            seeds = [];
            collectedSeeds = 0;
            seedSpawnTimer = 0;
            totalSeedsSpawned = 0;
            isGoldenPom = false;

            // Initialize fire particles
            fireParticles = [];
            fireFlareIntensity = 0;
            fallingIntoFire = false;
            fireDeathTimer = 0;
            initFireParticles();
        }

        // Initialize Hades fire particles
        function initFireParticles() {
            fireParticles = [];
            for (let i = 0; i < FIRE_PARTICLE_COUNT; i++) {
                fireParticles.push(createFireParticle(Math.random() * width));
            }
        }

        // Create a single fire particle
        function createFireParticle(x) {
            const baseHeight = FIRE_HEIGHT * scale;
            return {
                x: x,
                y: 0, // Relative to fire base (bottom of screen)
                baseX: x, // Original x for wave motion
                vx: (Math.random() - 0.5) * 20,
                vy: -Math.random() * 80 - 40, // Upward velocity
                size: Math.random() * 25 + 15,
                maxHeight: Math.random() * baseHeight * 0.8 + baseHeight * 0.4,
                life: Math.random(), // 0-1 phase offset for animation
                speed: Math.random() * 0.5 + 0.5, // Animation speed multiplier
                hue: Math.random() * 40 // 0-40 for red-orange-yellow range
            };
        }

        function placeRamp(x, y) {
            if (gameState !== 'playing' || !nextRamp) return;

            // Convert screen coordinates to world coordinates
            const worldY = y + cameraY;
            const ramp = createRamp(x, worldY, nextRamp.angle, nextRamp.length);
            ramps.push(ramp);
            nextRamp = generateRandomRamp();
        }

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let t = lenSq !== 0 ? dot / lenSq : -1;

            t = Math.max(0, Math.min(1, t));

            const nearestX = x1 + t * C;
            const nearestY = y1 + t * D;

            return {
                distance: Math.sqrt((px - nearestX) ** 2 + (py - nearestY) ** 2),
                t,
                nearestX,
                nearestY
            };
        }

        function updatePomegranate(dt) {
            if (gameState !== 'playing') return;

            const effectiveSpeed = BASE_ROLL_SPEED * speedMultiplier * scale;

            if (pom.onRamp) {
                // Rolling on a ramp
                const ramp = pom.onRamp;
                const rad = ramp.rad;

                // Move along ramp based on angle (steeper = faster)
                const rollSpeed = effectiveSpeed * (1 + Math.abs(Math.sin(rad)) * 1.5);
                const direction = ramp.angle > 0 ? 1 : -1; // Roll in direction of tilt

                pom.rampProgress += (rollSpeed * dt) / ramp.length * direction;

                // Calculate position on ramp
                const t = 0.5 + pom.rampProgress;
                pom.x = ramp.x1 + (ramp.x2 - ramp.x1) * t;
                pom.y = ramp.y1 + (ramp.y2 - ramp.y1) * t - pom.radius - 2;

                // Update rotation based on movement
                pom.rotation += rollSpeed * dt * direction / pom.radius;

                // Nib-bump effect: only bump when the calyx (nib) contacts the ramp
                // Calyx is at local angle -π/2 (top), hits ground when rotated to π/2 (bottom)
                const calyxAngle = (-Math.PI / 2 + pom.rotation) % (Math.PI * 2);
                const calyxDown = Math.sin(calyxAngle); // 1.0 when calyx points straight down

                // Only bump when calyx is contacting the surface
                const bumpThreshold = 0.85;
                if (calyxDown > bumpThreshold) {
                    // Intensity based on how directly the nib is hitting
                    const bumpIntensity = (calyxDown - bumpThreshold) / (1 - bumpThreshold);
                    // Vertical bump - lift the pomegranate slightly
                    pom.y -= bumpIntensity * 3 * scale;
                    pom.nibBump = bumpIntensity;
                } else {
                    pom.nibBump = 0;
                }

                // Check if fallen off ramp
                if (t < 0 || t > 1) {
                    pom.onRamp = null;
                    pom.vx = Math.cos(rad) * rollSpeed * direction;
                    pom.vy = Math.sin(rad) * rollSpeed * direction + 50;
                    ramp.passed = true;
                    fallStartY = pom.y; // Start tracking fall distance
                }
            } else {
                // Falling/airborne
                pom.vy += GRAVITY * dt;
                pom.x += pom.vx * dt;
                pom.y += pom.vy * dt;
                pom.rotation += pom.vx / pom.radius * dt;

                // Clear bouncing flag once we start falling again
                if (isBouncing && pom.vy > 0) {
                    isBouncing = false;
                }

                // Wall collisions
                if (pom.x - pom.radius < 0) {
                    pom.x = pom.radius;
                    pom.vx = -pom.vx * WALL_BOUNCE;
                }
                if (pom.x + pom.radius > width) {
                    pom.x = width - pom.radius;
                    pom.vx = -pom.vx * WALL_BOUNCE;
                }

                // Check bumper collisions (before ramp checks, bumpers take priority)
                checkBumperCollisions();

                // Check for ramp landing - use generous collision detection
                // Skip if currently bouncing (wait until falling again)
                if (!isBouncing) {
                for (const ramp of ramps) {
                    if (ramp.passed) continue;

                    // Check collision with bottom of pomegranate
                    const result = pointToLineDistance(pom.x, pom.y + pom.radius, ramp.x1, ramp.y1, ramp.x2, ramp.y2);

                    // Tighter landing threshold for better visual contact
                    const landingThreshold = RAMP_THICKNESS * scale + 5;

                    if (result.distance < landingThreshold && pom.vy > 0) {
                        // Check if we're within horizontal bounds of the ramp (with some margin)
                        const rampMinX = Math.min(ramp.x1, ramp.x2) - pom.radius;
                        const rampMaxX = Math.max(ramp.x1, ramp.x2) + pom.radius;

                        if (pom.x >= rampMinX && pom.x <= rampMaxX) {
                            // Check for bounce opportunity from a big fall
                            const bounceThreshold = 80 * scale;
                            let shouldBounce = false;

                            if (fallStartY !== null) {
                                const fallDistance = pom.y - fallStartY;

                                if (fallDistance > bounceThreshold) {
                                    // Snap pom to ramp surface first (so bounce looks right)
                                    const rampYAtPoint = ramp.y1 + (ramp.y2 - ramp.y1) * result.t;
                                    pom.y = rampYAtPoint - pom.radius - 2;

                                    // BOUNCE! Calculate upward velocity (strong enough to be clearly visible)
                                    const bounceVelocity = -Math.min(fallDistance * 1.2, 700);
                                    pom.vy = bounceVelocity;
                                    pom.vx = pom.vx * 0.8; // Retain some horizontal momentum

                                    // Increment combo counter
                                    comboCount++;
                                    const comboMultiplier = Math.min(comboCount, 10); // Cap at 10x

                                    // Award bonus points with combo multiplier
                                    const basePoints = Math.floor((fallDistance - bounceThreshold) / (2 * scale));
                                    const bonusPoints = basePoints * comboMultiplier * (isGoldenPom ? 2 : 1);
                                    if (bonusPoints > 0) {
                                        bonusScore += bonusPoints;
                                        if (comboCount >= 2) {
                                            addFloatingText(pom.x, pom.y - 30 * scale, `${comboCount}x COMBO!`);
                                            addFloatingText(pom.x, pom.y, `+${bonusPoints}`);
                                        } else {
                                            addFloatingText(pom.x, pom.y, `+${bonusPoints}`);
                                        }
                                    }

                                    // Set new fall start for potential chain bounce
                                    fallStartY = pom.y;
                                    isBouncing = true;
                                    shouldBounce = true;
                                }
                            }

                            if (!shouldBounce) {
                                // Normal landing
                                // Make all other ramps slightly translucent
                                for (const r of ramps) {
                                    if (r !== ramp && !r.passed && r.opacity > 0.5) {
                                        r.opacity = 0.5;
                                    }
                                }
                                // Land on ramp
                                pom.onRamp = ramp;
                                pom.rampProgress = result.t - 0.5;
                                pom.vx = 0;
                                pom.vy = 0;
                                // Snap to ramp surface
                                const rampYAtPoint = ramp.y1 + (ramp.y2 - ramp.y1) * result.t;
                                pom.y = rampYAtPoint - pom.radius - 2;
                                fallStartY = null; // Clear fall tracking
                                comboCount = 0; // Reset combo on normal landing
                            }
                            break;
                        }
                    }
                }
                } // end if (!isBouncing)

                // Game over check - pom fell below visible screen
                if (pom.y - pom.radius - cameraY > height && !fallingIntoFire) {
                    fallingIntoFire = true;
                    fireDeathTimer = 0;
                }
            }

            // Handle fire death animation
            if (fallingIntoFire && gameState === 'playing') {
                fireDeathTimer += dt;
                fireFlareIntensity = Math.min(1, fireDeathTimer / (FIRE_DEATH_DURATION * 0.5));

                if (fireDeathTimer >= FIRE_DEATH_DURATION) {
                    gameState = 'gameover';
                }
            }
        }

        function updateRamps(dt) {
            // Fade out passed ramps quickly
            for (let i = ramps.length - 1; i >= 0; i--) {
                if (ramps[i].passed) {
                    ramps[i].opacity -= dt * 2.5; // Fast fade (0.4 seconds)
                    if (ramps[i].opacity <= 0) {
                        ramps.splice(i, 1);
                    }
                }
            }
        }

        // Bumper functions
        function spawnBumper() {
            // Calculate depth multiplier for point scaling
            const depthMultiplier = 1 + Math.floor(maxDepth / DEPTH_VALUE_SCALE);

            // Check if we should spawn a jackpot bumper
            const timeSinceLastJackpot = gameTime - lastJackpotSpawnTime;
            const canSpawnJackpot = !hasActiveJackpot && timeSinceLastJackpot >= JACKPOT_SPAWN_INTERVAL;
            const spawnJackpot = canSpawnJackpot && Math.random() < 0.15; // 15% chance when eligible

            let radius, size, points, isJackpot, hitsRemaining;

            if (spawnJackpot) {
                // Spawn jackpot bumper
                radius = JACKPOT_BUMPER.radius * scale;
                size = 'jackpot';
                points = JACKPOT_BUMPER.pointsPerHit;
                isJackpot = true;
                hitsRemaining = JACKPOT_BUMPER.maxHits;
            } else {
                // Weighted random size: 50% small, 35% medium, 15% large
                const sizeRoll = Math.random();
                if (sizeRoll < 0.5) size = 'small';
                else if (sizeRoll < 0.85) size = 'medium';
                else size = 'large';

                const config = BUMPER_CONFIGS[size];
                radius = config.radius * scale;
                // Apply depth multiplier to regular bumpers
                points = config.points * depthMultiplier;
                isJackpot = false;
                hitsRemaining = 0;
            }

            // Spawn below visible screen
            const spawnY = cameraY + height + 100 * scale + Math.random() * 200 * scale;

            // X position: random within margins
            const minX = BUMPER_SPAWN_MARGIN * scale + radius;
            const maxX = width - BUMPER_SPAWN_MARGIN * scale - radius;
            let spawnX = minX + Math.random() * (maxX - minX);

            // Check minimum distance from existing bumpers
            let validPosition = true;
            for (const b of bumpers) {
                const dist = Math.sqrt((spawnX - b.x) ** 2 + (spawnY - b.y) ** 2);
                if (dist < BUMPER_MIN_DISTANCE * scale + radius + b.radius) {
                    validPosition = false;
                    break;
                }
            }

            if (validPosition) {
                const config = isJackpot ? JACKPOT_BUMPER : BUMPER_CONFIGS[size];
                bumpers.push({
                    x: spawnX,
                    y: spawnY,
                    radius: radius,
                    baseRadius: radius, // Store original radius for shrinking
                    size: size,
                    points: points,
                    recoilTime: 0,
                    lightTime: 0,
                    baseColor: config.color,
                    lightColor: config.lightColor,
                    isJackpot: isJackpot,
                    hitsRemaining: hitsRemaining,
                    pulsePhase: 0 // For jackpot pulsing animation
                });

                if (isJackpot) {
                    hasActiveJackpot = true;
                    lastJackpotSpawnTime = gameTime;
                }
            }
        }

        function updateBumperSpawning(dt) {
            bumperSpawnTimer += dt;

            // Spawn interval decreases with speed (more bumpers at higher speeds)
            const spawnInterval = BUMPER_MAX_SPAWN_INTERVAL -
                (BUMPER_MAX_SPAWN_INTERVAL - BUMPER_MIN_SPAWN_INTERVAL) *
                Math.min(speedMultiplier / 3, 1);

            if (bumperSpawnTimer >= nextBumperSpawnTime) {
                spawnBumper();
                bumperSpawnTimer = 0;
                nextBumperSpawnTime = spawnInterval * (0.5 + Math.random() * 0.5);
            }
        }

        function updateBumpers(dt) {
            if (gameState === 'playing') {
                updateBumperSpawning(dt);
                // Track maximum depth for scaling bumper values
                maxDepth = Math.max(maxDepth, pom.y);
            }

            // Update animations and remove off-screen bumpers
            for (let i = bumpers.length - 1; i >= 0; i--) {
                const bumper = bumpers[i];

                // Update recoil animation
                if (bumper.recoilTime > 0) {
                    bumper.recoilTime = Math.max(0, bumper.recoilTime - dt);
                }

                // Update light animation
                if (bumper.lightTime > 0) {
                    bumper.lightTime = Math.max(0, bumper.lightTime - dt);
                }

                // Update jackpot pulse animation
                if (bumper.isJackpot) {
                    bumper.pulsePhase += dt * 3; // Pulse speed
                }

                // Remove bumpers that have scrolled off the TOP of the screen
                const screenY = bumper.y - cameraY;
                if (screenY < -bumper.radius * 2 - 100) {
                    if (bumper.isJackpot) {
                        hasActiveJackpot = false; // Allow new jackpot to spawn
                    }
                    bumpers.splice(i, 1);
                }
            }
        }

        function checkBumperCollisions() {
            for (let i = bumpers.length - 1; i >= 0; i--) {
                const bumper = bumpers[i];
                // Calculate distance between centers
                const dx = pom.x - bumper.x;
                const dy = pom.y - bumper.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDist = pom.radius + bumper.radius;

                if (distance < minDist && distance > 0) {
                    // Collision detected - normalize direction vector
                    const nx = dx / distance;
                    const ny = dy / distance;

                    // Apply velocity away from bumper center
                    const bounceSpeed = BUMPER_BOUNCE_FORCE * scale * (1 + speedMultiplier * 0.2);
                    pom.vx = nx * bounceSpeed;
                    pom.vy = ny * bounceSpeed;

                    // If on ramp, leave it
                    if (pom.onRamp) {
                        pom.onRamp.passed = true;
                        pom.onRamp = null;
                    }

                    // Trigger bumper hit effects
                    bumper.recoilTime = BUMPER_RECOIL_DURATION;
                    bumper.lightTime = BUMPER_LIGHT_DURATION;

                    // Increment combo counter (bumpers participate in combo system)
                    comboCount++;
                    const comboMultiplier = Math.min(comboCount, 10);

                    // Handle jackpot vs regular bumper
                    if (bumper.isJackpot) {
                        // Jackpot bumper hit
                        bumper.hitsRemaining--;
                        const hitPoints = JACKPOT_BUMPER.pointsPerHit * comboMultiplier * (isGoldenPom ? 2 : 1);
                        bonusScore += hitPoints;

                        if (bumper.hitsRemaining <= 0) {
                            // JACKPOT! Final hit
                            const jackpotBonus = JACKPOT_BUMPER.jackpotBonus * (isGoldenPom ? 2 : 1);
                            bonusScore += jackpotBonus;
                            addFloatingText(bumper.x, bumper.y - bumper.radius - 40 * scale, '★ JACKPOT! ★');
                            addFloatingText(bumper.x, bumper.y - bumper.radius - 20 * scale, `+${jackpotBonus}`);
                            addFloatingText(bumper.x, bumper.y - bumper.radius, `+${hitPoints}`);
                            // Remove the jackpot bumper
                            hasActiveJackpot = false;
                            bumpers.splice(i, 1);
                        } else {
                            // Shrink the jackpot bumper
                            bumper.radius = bumper.baseRadius * (1 - JACKPOT_BUMPER.shrinkPerHit * (JACKPOT_BUMPER.maxHits - bumper.hitsRemaining));
                            // Show hit and remaining
                            if (comboCount >= 2) {
                                addFloatingText(bumper.x, bumper.y - bumper.radius - 35 * scale, `${comboCount}x COMBO!`);
                            }
                            addFloatingText(bumper.x, bumper.y - bumper.radius - 20 * scale, `${bumper.hitsRemaining} LEFT!`);
                            addFloatingText(bumper.x, bumper.y - bumper.radius, `+${hitPoints}`);
                        }
                    } else {
                        // Regular bumper
                        const totalPoints = bumper.points * comboMultiplier * (isGoldenPom ? 2 : 1);
                        bonusScore += totalPoints;

                        // Show combo and points
                        if (comboCount >= 2) {
                            addFloatingText(bumper.x, bumper.y - bumper.radius - 20 * scale, `${comboCount}x COMBO!`);
                        }
                        addFloatingText(bumper.x, bumper.y - bumper.radius, `+${totalPoints}`);
                    }

                    // Push pomegranate outside bumper
                    const overlap = minDist - distance;
                    pom.x += nx * (overlap + 2);
                    pom.y += ny * (overlap + 2);

                    // Set fall tracking for combo continuation
                    fallStartY = pom.y;
                    isBouncing = true;

                    break; // Only one collision per frame
                }
            }
        }

        // Seed spawning and collection
        function spawnSeed() {
            if (totalSeedsSpawned >= MAX_SEEDS) return;

            // Spawn below current camera view, in the upcoming area
            const spawnY = cameraY + height + 100 + Math.random() * 200;
            const margin = 80 * scale;
            const spawnX = margin + Math.random() * (width - margin * 2);

            // Check distance from existing bumpers (don't overlap)
            for (const bumper of bumpers) {
                const dx = spawnX - bumper.x;
                const dy = spawnY - bumper.y;
                if (Math.sqrt(dx * dx + dy * dy) < bumper.radius + 60 * scale) {
                    // Too close to bumper, skip this spawn attempt
                    return;
                }
            }

            seeds.push({
                x: spawnX,
                y: spawnY,
                pulsePhase: Math.random() * Math.PI * 2,
                collected: false
            });

            totalSeedsSpawned++;
        }

        function updateSeedSpawning(dt) {
            if (totalSeedsSpawned >= MAX_SEEDS || gameState !== 'playing') return;

            seedSpawnTimer += dt;

            if (seedSpawnTimer >= SEED_SPAWN_INTERVAL) {
                seedSpawnTimer = 0;
                spawnSeed();
            }
        }

        function updateSeeds(dt) {
            // Update pulse animation for all seeds
            for (const seed of seeds) {
                seed.pulsePhase += dt * 4;
            }

            // Remove seeds that have scrolled off the top of the screen
            for (let i = seeds.length - 1; i >= 0; i--) {
                const seed = seeds[i];
                if (seed.y < cameraY - 100) {
                    seeds.splice(i, 1);
                }
            }
        }

        function checkSeedCollisions() {
            if (gameState !== 'playing') return;

            for (let i = seeds.length - 1; i >= 0; i--) {
                const seed = seeds[i];
                if (seed.collected) continue;

                const dx = pom.x - seed.x;
                const dy = pom.y - seed.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < pom.radius + SEED_COLLECT_RADIUS * scale) {
                    collectSeed(seed, i);
                }
            }
        }

        function collectSeed(seed, index) {
            collectedSeeds++;
            seed.collected = true;

            // Scaling bonus: 1000, 2000, 3000, 4000, 5000, 6000
            const seedBonus = collectedSeeds * 1000 * (isGoldenPom ? 2 : 1);
            bonusScore += seedBonus;

            // Speed boost: +1x per seed collected
            speedMultiplier += 1;

            // Visual feedback - floating text showing progress and points
            const screenY = seed.y - cameraY;
            addFloatingText(seed.x, screenY - 40, `SEED ${collectedSeeds}/6`);
            addFloatingText(seed.x, screenY - 20, `+${seedBonus}`);
            addFloatingText(seed.x, screenY, '+1x SPEED!');

            // Create sparkle burst effect
            createSeedCollectEffect(seed.x, screenY);

            // Remove the seed
            seeds.splice(index, 1);

            // Check for golden transformation
            if (collectedSeeds >= MAX_SEEDS) {
                activateGoldenPom();
            }
        }

        function createSeedCollectEffect(x, y) {
            // Sparkle burst - 12 particles radiating outward
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const speed = 80 + Math.random() * 40;
                floatingTexts.push({
                    x: x,
                    y: y,
                    text: '✦',  // Sparkle character
                    age: 0,
                    maxAge: 0.6,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 30
                });
            }
        }

        function activateGoldenPom() {
            isGoldenPom = true;

            // Big celebratory floating texts
            addFloatingText(pom.x, pom.y - cameraY - 60, 'GOLDEN POM!');
            addFloatingText(pom.x, pom.y - cameraY - 30, '2x POINTS!');
        }

        // Floating text functions for bonus points display
        function addFloatingText(x, y, text) {
            floatingTexts.push({
                x,
                y,
                text,
                age: 0,
                maxAge: 1.5
            });
        }

        function updateFloatingTexts(dt) {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                ft.age += dt;
                
                // Support custom velocity or default float upward
                if (ft.vx !== undefined || ft.vy !== undefined) {
                    ft.x += (ft.vx || 0) * dt;
                    ft.y += (ft.vy || 0) * dt;
                    // Apply gravity to particles
                    if (ft.vy !== undefined) {
                        ft.vy += 200 * dt;
                    }
                } else {
                    ft.y -= 60 * scale * dt; // Float upward
                }
                
                if (ft.age >= ft.maxAge) {
                    floatingTexts.splice(i, 1);
                }
            }
        }

        function drawFloatingTexts() {
            for (const ft of floatingTexts) {
                const progress = ft.age / ft.maxAge;
                const alpha = Math.max(0, 1 - progress * progress); // Ease out fade

                // Rainbow: rapidly cycle through hues
                const hue = (Date.now() / 5 + ft.x) % 360;

                // Shimmer: oscillate position slightly
                const shimmerX = Math.sin(ft.age * 15) * 3 * scale;
                const shimmerY = Math.sin(ft.age * 12) * 2 * scale;

                // Scale: start big, shrink slightly
                const textScale = 1 + (1 - progress) * 0.3;

                ctx.save();
                ctx.globalAlpha = alpha;

                // Glow effect
                ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
                ctx.shadowBlur = 15 * scale;

                ctx.font = `bold ${24 * scale * textScale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillStyle = `hsl(${hue}, 100%, 70%)`;

                const drawX = ft.x + shimmerX;
                const drawY = ft.y - cameraY + shimmerY;

                // Draw outline for visibility
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3 * scale;
                ctx.strokeText(ft.text, drawX, drawY);

                // Draw fill
                ctx.fillText(ft.text, drawX, drawY);

                ctx.restore();
            }
        }

        function update(dt) {
            if (gameState === 'playing') {
                gameTime += dt;
                score = Math.floor(gameTime * 10) + bonusScore;
                speedMultiplier = 1 + gameTime * SPEED_INCREASE_RATE;

                // Camera smoothly follows pom, keeping it at ~1/3 from top
                const targetCameraY = pom.y - height / 3;
                const diff = targetCameraY - cameraY;

                // Minimum camera speed scales with game speed
                const minSpeed = BASE_ROLL_SPEED * scale * speedMultiplier * 0.7;

                // Calculate desired velocity based on distance to target
                let targetVelocity = diff * 2.5;

                // When scrolling down, ensure at least minimum speed
                if (diff > 0) {
                    targetVelocity = Math.max(minSpeed, targetVelocity);
                }

                // Smoothly adjust camera velocity (adds inertia, prevents jerky motion)
                cameraVelocity += (targetVelocity - cameraVelocity) * 4 * dt;

                // Apply velocity
                cameraY += cameraVelocity * dt;

                // Don't overshoot when close to target
                if (diff > 0 && cameraY > targetCameraY) {
                    cameraY = targetCameraY;
                }
            } else if (gameState === 'gameover') {
                gameOverRotation += dt; // Rotate 1 radian per second
                gameOverFadeIn = Math.min(1, gameOverFadeIn + dt * 1.5); // Fade in over ~0.7 seconds
            }

            updatePomegranate(dt);
            updateRamps(dt);
            updateBumpers(dt);
            updateSeedSpawning(dt);
            updateSeeds(dt);
            checkSeedCollisions();
            updateFloatingTexts(dt);
            updateFire(dt);
        }

        // Update Hades fire effect
        function updateFire(dt) {
            const time = gameTime;

            // Update flare intensity (ramps up on game over)
            if (gameState === 'gameover') {
                fireFlareIntensity = Math.min(1, fireFlareIntensity + dt * 3);
            } else {
                fireFlareIntensity = Math.max(0, fireFlareIntensity - dt * 2);
            }

            // Update each fire particle
            for (let i = 0; i < fireParticles.length; i++) {
                const p = fireParticles[i];

                // Animate life cycle
                p.life += dt * p.speed * (1 + fireFlareIntensity);
                if (p.life > 1) p.life -= 1;

                // Calculate current height based on life cycle (rises then falls)
                const cycle = Math.sin(p.life * Math.PI);
                p.y = cycle * p.maxHeight * (1 + fireFlareIntensity * 0.8);

                // Horizontal wave motion
                p.x = p.baseX + Math.sin(time * 3 + p.baseX * 0.01) * 15;

                // Reset particles that drift too far
                if (p.baseX < -50 || p.baseX > width + 50) {
                    p.baseX = Math.random() * width;
                    p.x = p.baseX;
                }
            }

            // Spawn extra particles during flare
            if (fireFlareIntensity > 0.5 && Math.random() < fireFlareIntensity * 0.3) {
                fireParticles.push(createFireParticle(Math.random() * width));
            }

            // Remove excess particles when not flaring
            if (fireFlareIntensity < 0.1 && fireParticles.length > FIRE_PARTICLE_COUNT) {
                fireParticles.splice(FIRE_PARTICLE_COUNT);
            }
        }

        function drawPomegranate() {
            ctx.save();
            ctx.translate(pom.x, pom.y - cameraY);
            ctx.rotate(pom.rotation);

            // Apply squash only during nib bump (not constant wobble)
            const squash = 1 + (pom.nibBump || 0) * 0.08;
            ctx.scale(1 / squash, squash);

            // Golden glow effect when golden
            if (isGoldenPom) {
                const pulseIntensity = 0.6 + 0.3 * Math.sin(gameTime * 5);
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 25 * scale * pulseIntensity;
            }

            // Main body gradient - golden or red depending on state
            const gradient = ctx.createRadialGradient(-pom.radius * 0.3, -pom.radius * 0.3, 0, 0, 0, pom.radius);
            if (isGoldenPom) {
                gradient.addColorStop(0, '#FFE066');   // Bright gold highlight
                gradient.addColorStop(0.5, '#FFD700'); // Gold
                gradient.addColorStop(1, '#B8860B');   // Dark gold
            } else {
                gradient.addColorStop(0, '#c41e3a');
                gradient.addColorStop(0.5, '#8b0000');
                gradient.addColorStop(1, '#4a0000');
            }

            // Slightly irregular shape (static only - no dynamic wobble)
            ctx.beginPath();
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const staticWobble = 1 + Math.sin(i * 3) * 0.05;
                const r = pom.radius * staticWobble;
                if (i === 0) {
                    ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                } else {
                    ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                }
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Reset shadow for other elements
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            // Calyx (crown) on top - golden if golden pom
            ctx.fillStyle = isGoldenPom ? '#8B7355' : '#654321';
            ctx.beginPath();
            const calyxY = -pom.radius * 0.8;
            ctx.moveTo(-pom.radius * 0.25, calyxY);
            ctx.lineTo(-pom.radius * 0.15, calyxY - pom.radius * 0.35);
            ctx.lineTo(0, calyxY - pom.radius * 0.25);
            ctx.lineTo(pom.radius * 0.15, calyxY - pom.radius * 0.35);
            ctx.lineTo(pom.radius * 0.25, calyxY);
            ctx.closePath();
            ctx.fill();

            // Highlight
            ctx.beginPath();
            ctx.arc(-pom.radius * 0.3, -pom.radius * 0.3, pom.radius * 0.25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fill();

            ctx.restore();
        }

        function drawRamp(ramp) {
            ctx.save();
            ctx.globalAlpha = ramp.opacity;

            // Apply camera offset to y coordinates
            const y1 = ramp.y1 - cameraY;
            const y2 = ramp.y2 - cameraY;

            // Wood grain effect
            const gradient = ctx.createLinearGradient(ramp.x1, y1, ramp.x2, y2);
            gradient.addColorStop(0, '#8B7355');
            gradient.addColorStop(0.3, '#A0896C');
            gradient.addColorStop(0.5, '#8B7355');
            gradient.addColorStop(0.7, '#9C8162');
            gradient.addColorStop(1, '#8B7355');

            ctx.strokeStyle = gradient;
            ctx.lineWidth = RAMP_THICKNESS * scale;
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(ramp.x1, y1);
            ctx.lineTo(ramp.x2, y2);
            ctx.stroke();

            // Edge highlight
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.moveTo(ramp.x1, y1 - RAMP_THICKNESS * scale * 0.3);
            ctx.lineTo(ramp.x2, y2 - RAMP_THICKNESS * scale * 0.3);
            ctx.stroke();

            ctx.restore();
        }

        // Color helper functions
        function lightenColor(hex, amount) {
            const num = parseInt(hex.slice(1), 16);
            const r = Math.min(255, ((num >> 16) & 0xFF) + 255 * amount);
            const g = Math.min(255, ((num >> 8) & 0xFF) + 255 * amount);
            const b = Math.min(255, (num & 0xFF) + 255 * amount);
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }

        function darkenColor(hex, amount) {
            const num = parseInt(hex.slice(1), 16);
            const r = ((num >> 16) & 0xFF) * (1 - amount);
            const g = ((num >> 8) & 0xFF) * (1 - amount);
            const b = (num & 0xFF) * (1 - amount);
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }

        function drawBumper(bumper) {
            const screenY = bumper.y - cameraY;

            // Skip if off-screen
            if (screenY < -bumper.radius * 2 || screenY > height + bumper.radius * 2) {
                return;
            }

            ctx.save();
            ctx.translate(bumper.x, screenY);

            // Calculate recoil scale (smooth sine pulse)
            const recoilProgress = bumper.recoilTime / BUMPER_RECOIL_DURATION;
            const recoilScale = 1 - (1 - BUMPER_RECOIL_SCALE) * Math.sin(recoilProgress * Math.PI);
            ctx.scale(recoilScale, recoilScale);

            // Jackpot bumper: pulsing glow effect (always on)
            if (bumper.isJackpot) {
                const pulseIntensity = 0.3 + 0.2 * Math.sin(bumper.pulsePhase);
                ctx.globalAlpha = pulseIntensity;
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 25 * scale;
                ctx.beginPath();
                ctx.arc(0, 0, bumper.radius * 1.15, 0, Math.PI * 2);
                ctx.fillStyle = '#FFD700';
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }

            // Light burst effect (when hit) - draw first so it's behind
            if (bumper.lightTime > 0) {
                const lightProgress = bumper.lightTime / BUMPER_LIGHT_DURATION;
                ctx.globalAlpha = lightProgress * 0.6;
                ctx.shadowColor = bumper.lightColor;
                ctx.shadowBlur = (bumper.isJackpot ? 50 : 30) * scale * lightProgress;

                // Expanding ring burst
                const burstRadius = bumper.radius * (1.2 + (1 - lightProgress) * 0.5);
                ctx.beginPath();
                ctx.arc(0, 0, burstRadius, 0, Math.PI * 2);
                ctx.strokeStyle = bumper.lightColor;
                ctx.lineWidth = (bumper.isJackpot ? 10 : 6) * scale * lightProgress;
                ctx.stroke();

                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }

            // Outer ring - gold for jackpot, chrome for regular
            ctx.beginPath();
            ctx.arc(0, 0, bumper.radius, 0, Math.PI * 2);
            const ringGradient = ctx.createRadialGradient(
                -bumper.radius * 0.3, -bumper.radius * 0.3, 0,
                0, 0, bumper.radius
            );
            if (bumper.isJackpot) {
                ringGradient.addColorStop(0, '#FFF8DC');
                ringGradient.addColorStop(0.4, '#FFD700');
                ringGradient.addColorStop(0.8, '#DAA520');
                ringGradient.addColorStop(1, '#B8860B');
            } else {
                ringGradient.addColorStop(0, '#F0F0F0');
                ringGradient.addColorStop(0.4, '#B0B0B0');
                ringGradient.addColorStop(0.8, '#606060');
                ringGradient.addColorStop(1, '#303030');
            }
            ctx.fillStyle = ringGradient;
            ctx.fill();

            // Decorative ring groove
            ctx.beginPath();
            ctx.arc(0, 0, bumper.radius * 0.88, 0, Math.PI * 2);
            ctx.strokeStyle = bumper.isJackpot ? '#B8860B' : '#404040';
            ctx.lineWidth = 2 * scale;
            ctx.stroke();

            // Inner colored cap
            const capRadius = bumper.radius * 0.72;
            ctx.beginPath();
            ctx.arc(0, 0, capRadius, 0, Math.PI * 2);
            const capGradient = ctx.createRadialGradient(
                -capRadius * 0.3, -capRadius * 0.3, 0,
                0, 0, capRadius
            );
            capGradient.addColorStop(0, lightenColor(bumper.baseColor, 0.4));
            capGradient.addColorStop(0.4, bumper.baseColor);
            capGradient.addColorStop(1, darkenColor(bumper.baseColor, 0.4));
            ctx.fillStyle = capGradient;
            ctx.fill();

            // Inner ring on cap
            ctx.beginPath();
            ctx.arc(0, 0, capRadius * 0.75, 0, Math.PI * 2);
            ctx.strokeStyle = darkenColor(bumper.baseColor, 0.2);
            ctx.lineWidth = 2 * scale;
            ctx.stroke();

            // For jackpot: draw hit indicators (dots around edge)
            if (bumper.isJackpot && bumper.hitsRemaining > 0) {
                const dotRadius = 4 * scale;
                for (let i = 0; i < bumper.hitsRemaining; i++) {
                    const angle = (i / JACKPOT_BUMPER.maxHits) * Math.PI * 2 - Math.PI / 2;
                    const dotX = Math.cos(angle) * bumper.radius * 0.82;
                    const dotY = Math.sin(angle) * bumper.radius * 0.82;
                    ctx.beginPath();
                    ctx.arc(dotX, dotY, dotRadius, 0, Math.PI * 2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fill();
                }
            }

            // Point value text
            const fontSize = bumper.isJackpot ? bumper.radius * 0.4 : bumper.radius * 0.55;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Text shadow/outline for visibility
            ctx.fillStyle = darkenColor(bumper.baseColor, 0.5);
            const displayText = bumper.isJackpot ? '1000' : bumper.points;
            ctx.fillText(displayText, 1 * scale, 1 * scale);

            // Main text
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(displayText, 0, 0);

            // Jackpot label below points
            if (bumper.isJackpot) {
                const labelSize = bumper.radius * 0.22;
                ctx.font = `bold ${labelSize}px Arial`;
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText('JACKPOT', 0, fontSize * 0.5);
            }

            // Highlight on hit
            if (bumper.lightTime > 0) {
                const lightProgress = bumper.lightTime / BUMPER_LIGHT_DURATION;
                ctx.globalAlpha = lightProgress * 0.7;

                // Bright flash on cap
                ctx.beginPath();
                ctx.arc(0, 0, capRadius, 0, Math.PI * 2);
                ctx.fillStyle = bumper.lightColor;
                ctx.fill();

                // Re-draw text on top of flash
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(displayText, 0, 0);
                if (bumper.isJackpot) {
                    const labelSize = bumper.radius * 0.22;
                    ctx.font = `bold ${labelSize}px Arial`;
                    ctx.fillText('JACKPOT', 0, fontSize * 0.5);
                }

                ctx.globalAlpha = 1;
            }

            // Top highlight reflection
            ctx.beginPath();
            ctx.arc(-bumper.radius * 0.25, -bumper.radius * 0.3, bumper.radius * 0.18, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();

            ctx.restore();
        }

        // Draw a collectible pomegranate seed
        function drawSeed(x, y, pulse = 0) {
            ctx.save();
            ctx.translate(x, y);

            // Pulsing glow effect (to make it noticeable)
            const glowRadius = 25 * scale * (1 + pulse * 0.3);
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
            glowGradient.addColorStop(0, 'rgba(255, 100, 150, 0.5)');
            glowGradient.addColorStop(0.5, 'rgba(255, 50, 100, 0.2)');
            glowGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
            ctx.fill();

            // Seed body - teardrop shape
            const seedHeight = 18 * scale;
            const seedWidth = 12 * scale;

            // Create gradient for jewel-like appearance
            const bodyGradient = ctx.createRadialGradient(
                -seedWidth * 0.2, -seedHeight * 0.2, 0,
                0, 0, seedHeight * 0.7
            );
            bodyGradient.addColorStop(0, '#ff6b8a');   // Light pink highlight
            bodyGradient.addColorStop(0.3, '#dc143c'); // Crimson
            bodyGradient.addColorStop(0.7, '#8b0a1a'); // Dark ruby
            bodyGradient.addColorStop(1, '#4a0010');   // Deep shadow

            // Draw teardrop shape
            ctx.beginPath();
            ctx.moveTo(0, -seedHeight * 0.5);  // Top
            ctx.bezierCurveTo(
                seedWidth * 0.6, -seedHeight * 0.3,
                seedWidth * 0.5, seedHeight * 0.3,
                0, seedHeight * 0.5
            );
            ctx.bezierCurveTo(
                -seedWidth * 0.5, seedHeight * 0.3,
                -seedWidth * 0.6, -seedHeight * 0.3,
                0, -seedHeight * 0.5
            );
            ctx.fillStyle = bodyGradient;
            ctx.fill();

            // Glossy highlight
            ctx.beginPath();
            ctx.ellipse(-seedWidth * 0.15, -seedHeight * 0.2, seedWidth * 0.25, seedHeight * 0.18, -0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fill();

            ctx.restore();
        }

        // Draw mini seed for UI progress display
        function drawMiniSeed(x, y, size, filled) {
            ctx.save();
            ctx.translate(x, y);

            // Simplified teardrop for small display
            ctx.beginPath();
            ctx.moveTo(0, -size * 0.5);
            ctx.bezierCurveTo(size * 0.5, -size * 0.3, size * 0.4, size * 0.3, 0, size * 0.5);
            ctx.bezierCurveTo(-size * 0.4, size * 0.3, -size * 0.5, -size * 0.3, 0, -size * 0.5);

            if (filled) {
                ctx.fillStyle = isGoldenPom ? '#FFD700' : '#dc143c';
                ctx.fill();
            } else {
                ctx.strokeStyle = 'rgba(220, 20, 60, 0.5)';
                ctx.lineWidth = 1.5 * scale;
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawNextRampPreview() {
            if (!nextRamp) return;

            // Fade out during game over transition
            const fadeOut = gameState === 'gameover' || fallingIntoFire ? 1 - gameOverFadeIn : 1;
            if (fadeOut <= 0) return;

            const previewX = width - 60 * scale;
            const previewY = height - 60 * scale;
            const previewScale = 0.4;

            ctx.save();
            ctx.globalAlpha = fadeOut;

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.roundRect(previewX - 50 * scale, previewY - 40 * scale, 100 * scale, 80 * scale, 10 * scale);
            ctx.fill();

            // Label
            ctx.fillStyle = '#fff';
            ctx.font = `${12 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('NEXT', previewX, previewY - 25 * scale);

            // Preview ramp
            const rad = nextRamp.angle * Math.PI / 180;
            const len = nextRamp.length * previewScale;

            ctx.strokeStyle = '#A0896C';
            ctx.lineWidth = RAMP_THICKNESS * scale * previewScale;
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(previewX - Math.cos(rad) * len / 2, previewY - Math.sin(rad) * len / 2);
            ctx.lineTo(previewX + Math.cos(rad) * len / 2, previewY + Math.sin(rad) * len / 2);
            ctx.stroke();

            ctx.restore();
        }

        function drawGhostRamp() {
            if (!ghostPosition || !nextRamp || gameState !== 'playing') return;

            const rad = nextRamp.angle * Math.PI / 180;
            const len = nextRamp.length;
            const x = ghostPosition.x;
            const y = ghostPosition.y;

            ctx.save();
            ctx.globalAlpha = 0.4;

            // Ghost ramp with same style but translucent
            ctx.strokeStyle = '#A0896C';
            ctx.lineWidth = RAMP_THICKNESS * scale;
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(x - Math.cos(rad) * len / 2, y - Math.sin(rad) * len / 2);
            ctx.lineTo(x + Math.cos(rad) * len / 2, y + Math.sin(rad) * len / 2);
            ctx.stroke();

            ctx.restore();
        }

        function drawScore() {
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${24 * scale}px Arial`;
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 20 * scale, 40 * scale);

            // Speed indicator
            ctx.font = `${14 * scale}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillText(`Speed: ${speedMultiplier.toFixed(1)}x`, 20 * scale, 60 * scale);
        }

        function drawSeedProgress() {
            const startX = 20 * scale;
            const startY = 82 * scale;
            const seedSize = 10 * scale;
            const spacing = 18 * scale;

            ctx.font = `${14 * scale}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.textAlign = 'left';
            ctx.fillText('Seeds:', startX, startY);

            // Draw 6 seed indicators
            for (let i = 0; i < MAX_SEEDS; i++) {
                const x = startX + 55 * scale + i * spacing;
                const y = startY - seedSize * 0.3;

                if (i < collectedSeeds) {
                    // Collected - draw filled seed
                    drawMiniSeed(x, y, seedSize, true);
                } else if (i < totalSeedsSpawned) {
                    // Spawned but not collected - draw outline
                    drawMiniSeed(x, y, seedSize, false);
                } else {
                    // Not yet spawned - draw dim placeholder circle
                    ctx.beginPath();
                    ctx.arc(x, y, seedSize * 0.4, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.fill();
                }
            }

            // Show golden indicator if achieved
            if (isGoldenPom) {
                ctx.font = `bold ${12 * scale}px Arial`;
                ctx.fillStyle = '#FFD700';
                ctx.fillText('2x GOLDEN!', startX, startY + 18 * scale);
            }
        }

        function drawVersion() {
            ctx.font = `${10 * scale}px Arial`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.textAlign = 'right';
            ctx.fillText(VERSION, width - 10 * scale, height - 10 * scale);
        }

        function drawPomegranateAt(x, y, radius, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);

            // Main body - deep red/burgundy with gradient
            const gradient = ctx.createRadialGradient(-radius * 0.3, -radius * 0.3, 0, 0, 0, radius);
            gradient.addColorStop(0, '#c41e3a');
            gradient.addColorStop(0.5, '#8b0000');
            gradient.addColorStop(1, '#4a0000');

            // Slightly irregular shape
            ctx.beginPath();
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const staticWobble = 1 + Math.sin(i * 3) * 0.05;
                const r = radius * staticWobble;
                if (i === 0) {
                    ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                } else {
                    ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                }
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Calyx (crown) on top
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            const calyxY = -radius * 0.8;
            ctx.moveTo(-radius * 0.25, calyxY);
            ctx.lineTo(-radius * 0.15, calyxY - radius * 0.35);
            ctx.lineTo(0, calyxY - radius * 0.25);
            ctx.lineTo(radius * 0.15, calyxY - radius * 0.35);
            ctx.lineTo(radius * 0.25, calyxY);
            ctx.closePath();
            ctx.fill();

            // Highlight
            ctx.beginPath();
            ctx.arc(-radius * 0.3, -radius * 0.3, radius * 0.25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fill();

            ctx.restore();
        }

        function drawGameOver() {
            const fade = gameOverFadeIn;

            // Darken background (fades in)
            ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * fade})`;
            ctx.fillRect(0, 0, width, height);

            // Draw the pomegranate in the center, slowly rotating (fades in)
            ctx.globalAlpha = fade;
            const pomY = height / 2 - 80 * scale;
            const pomRadius = 40 * scale;
            drawPomegranateAt(width / 2, pomY, pomRadius, gameOverRotation);
            ctx.globalAlpha = 1;

            // Game over text (fades in)
            ctx.fillStyle = `rgba(255, 255, 255, ${fade})`;
            ctx.font = `bold ${48 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', width / 2, height / 2 + 20 * scale);

            ctx.font = `${32 * scale}px Arial`;
            ctx.fillText(`Score: ${score}`, width / 2, height / 2 + 70 * scale);

            ctx.font = `${20 * scale}px Arial`;
            ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * fade})`;
            ctx.fillText('Tap to restart', width / 2, height / 2 + 120 * scale);
        }

        // Draw Hades fire effect at the bottom of the screen
        function drawFire() {
            const baseY = height;
            const intensity = 1 + fireFlareIntensity * 0.5;

            // Draw base glow using smooth exponential decay (no banding)
            const glowGradient = ctx.createLinearGradient(0, baseY, 0, 0);
            // Use many stops with smooth exponential-like decay to avoid banding
            const glowStops = 20;
            for (let i = 0; i <= glowStops; i++) {
                const t = i / glowStops;
                // Exponential decay: opacity drops smoothly from 0.8 to near 0
                const opacity = 0.8 * Math.pow(1 - t, 2.5) * intensity;
                // Color shifts from bright orange-red at base to dark red at top
                const r = Math.round(200 - t * 160);
                const g = Math.round(50 - t * 45);
                const b = Math.round(10 - t * 10);
                glowGradient.addColorStop(t, `rgba(${r}, ${g}, ${b}, ${opacity})`);
            }
            ctx.fillStyle = glowGradient;
            ctx.fillRect(0, 0, width, height);

            // Sort particles by size for layering (smaller = background)
            const sortedParticles = [...fireParticles].sort((a, b) => a.size - b.size);

            // Draw each flame particle
            for (const p of sortedParticles) {
                const flameHeight = p.y * intensity;
                if (flameHeight < 5) continue; // Skip tiny flames

                ctx.save();
                ctx.translate(p.x, baseY);

                // Create flame gradient (white core -> yellow -> orange -> red -> transparent)
                const gradient = ctx.createLinearGradient(0, 0, 0, -flameHeight);
                const hue = p.hue + fireFlareIntensity * 10; // Shift yellower during flare

                gradient.addColorStop(0, `hsla(${hue}, 100%, 90%, 1)`); // White-ish core
                gradient.addColorStop(0.15, `hsla(${hue + 10}, 100%, 60%, 0.95)`); // Yellow
                gradient.addColorStop(0.4, `hsla(${hue}, 100%, 50%, 0.85)`); // Orange
                gradient.addColorStop(0.7, `hsla(${Math.max(0, hue - 20)}, 100%, 40%, 0.6)`); // Red
                gradient.addColorStop(1, 'transparent');

                // Draw flame shape using clip-path simulation with path
                ctx.beginPath();
                const w = p.size * (0.8 + fireFlareIntensity * 0.3);
                ctx.moveTo(0, -flameHeight); // Top point
                ctx.quadraticCurveTo(-w * 0.4, -flameHeight * 0.6, -w * 0.5, -flameHeight * 0.3);
                ctx.quadraticCurveTo(-w * 0.6, 0, 0, 0); // Left curve to bottom
                ctx.quadraticCurveTo(w * 0.6, 0, w * 0.5, -flameHeight * 0.3);
                ctx.quadraticCurveTo(w * 0.4, -flameHeight * 0.6, 0, -flameHeight); // Right curve to top
                ctx.closePath();

                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.restore();
            }

            // Add extra glow effect during flare (smooth exponential decay)
            if (fireFlareIntensity > 0.2) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const flareGradient = ctx.createLinearGradient(0, baseY, 0, 0);
                // Smooth exponential decay for flare glow
                const flareStops = 15;
                for (let i = 0; i <= flareStops; i++) {
                    const t = i / flareStops;
                    const opacity = fireFlareIntensity * 0.2 * Math.pow(1 - t, 3);
                    const r = Math.round(255 - t * 55);
                    const g = Math.round(100 - t * 60);
                    flareGradient.addColorStop(t, `rgba(${r}, ${g}, 0, ${opacity})`);
                }
                ctx.fillStyle = flareGradient;
                ctx.fillRect(0, 0, width, height);
                ctx.restore();
            }
        }

        function draw() {
            // Background gradient
            const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
            bgGradient.addColorStop(0, '#1a1a2e');
            bgGradient.addColorStop(1, '#16213e');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);

            // Draw walls (subtle)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, 4 * scale, height);
            ctx.fillRect(width - 4 * scale, 0, 4 * scale, height);

            // Draw ghost ramp preview
            drawGhostRamp();

            // Draw ramps
            for (const ramp of ramps) {
                drawRamp(ramp);
            }

            // Draw bumpers (on top of ramps)
            for (const bumper of bumpers) {
                drawBumper(bumper);
            }

            // Draw seeds
            for (const seed of seeds) {
                const screenY = seed.y - cameraY;
                if (screenY > -50 && screenY < height + 50) {
                    const pulse = Math.sin(seed.pulsePhase) * 0.5 + 0.5;
                    drawSeed(seed.x, screenY, pulse);
                }
            }

            // Draw pomegranate
            if (gameState === 'playing') {
                drawPomegranate();
            }

            // Draw floating bonus texts
            drawFloatingTexts();

            // Draw Hades fire during falling animation and game over
            if (fallingIntoFire || gameState === 'gameover') {
                drawFire();
            }

            // UI
            drawScore();
            drawSeedProgress();
            drawVersion();
            drawNextRampPreview();

            // Game over overlay
            if (gameState === 'gameover') {
                drawGameOver();
            }
        }

        // Input handling
        function handleInput(x, y) {
            if (gameState === 'gameover') {
                initGame();
            } else {
                placeRamp(x, y);
            }
        }

        canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            ghostPosition = { x: touch.clientX, y: touch.clientY };
            // On game over, restart immediately on touch
            if (gameState === 'gameover') {
                initGame();
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            ghostPosition = { x: touch.clientX, y: touch.clientY };
        });

        canvas.addEventListener('touchend', (e) => {
            // Place ramp where user releases (using last ghost position)
            if (gameState === 'playing' && ghostPosition) {
                placeRamp(ghostPosition.x, ghostPosition.y);
            }
            ghostPosition = null;
        });

        canvas.addEventListener('mousedown', (e) => {
            handleInput(e.clientX, e.clientY);
        });

        // Cheat key for playtesting: P to collect next seed
        document.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') {
                if (gameState === 'playing' && collectedSeeds < MAX_SEEDS) {
                    // Create a fake seed at pom position and collect it
                    const fakeSeed = {
                        x: pom.x,
                        y: pom.y,
                        pulsePhase: 0,
                        collected: false
                    };
                    collectSeed(fakeSeed, -1); // -1 index since it's not in the array
                    if (totalSeedsSpawned < MAX_SEEDS) {
                        totalSeedsSpawned++; // Count it as spawned too
                    }
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            ghostPosition = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mouseleave', () => {
            ghostPosition = null;
        });

        // Game loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1); // Cap delta time
            lastTime = timestamp;

            update(dt);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // Initialize
        window.addEventListener('resize', resize);
        resize();
        initGame();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
